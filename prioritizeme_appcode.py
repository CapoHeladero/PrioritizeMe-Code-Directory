# -*- coding: utf-8 -*-
"""PrioritizeMe AppCode

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/114a5mRlfF7NIhaE7o5gwruKgyVkTgbuP
"""

from datetime import datetime, timedelta
from typing import List, Dict, Optional
from enum import Enum
import heapq
from collections import defaultdict
from threading import Timer

class Taskcategory(Enum):
    Exam = "exam"
    Project = "project"
    Homework = "homework"
    Extracurricular = "extracurricular"

    def weight(self):
      weights = {
          Taskcategory.Exam: 0.8,
          Taskcategory.Project: 0.6,
          Taskcategory.Homework: 0.4,
          Taskcategory.Extracurricular: 0.2,
      }
      return weights[self]


class Taskstatus(Enum):
    Not_started = "not_started"
    In_progress = "in_progress"
    Finished = "completed"
    Overdue = "overdue"

    def weight(self):
        weights = {
            Taskstatus.Overdue: 1.0,
            Taskstatus.Not_started: 0.6,
            Taskstatus.In_progress: 0.8,
            Taskstatus.Finished: 0.2,
        }
        return weights[self]


class Taskpriority(Enum):
    Low = 1
    Medium = 2
    High = 3
    Urgent = 4

    def weight(self):
        return self.value / 4 # Normalise to 0.25, 0.5, 0.75, 1.0

def determine_priority_and_estimated_time(
    category: Taskcategory,
    days_until_deadline: int,
    status: Taskstatus
) -> (Taskpriority, int):
    """Automatically determine priority and estimated time based on task category,deadline, and status."""
    # Start with default values based on category and days_until_deadline

    if category == Taskcategory.Extracurricular:
        base_priority = Taskpriority.Low
        base_time = 1
    elif category == Taskcategory.Exam or days_until_deadline <= 2:
        base_priority = Taskpriority.Urgent
        base_time = 6
    elif category == Taskcategory.Project or days_until_deadline <= 3:
        base_priority = Taskpriority.High
        base_time = 4
    elif category == Taskcategory.Homework or days_until_deadline <= 7:
        base_priority = Taskpriority.Medium
        base_time = 2
    else:
        base_priority = Taskpriority.Low
        base_time = 1

    # Adjust based on status
    if status == Taskstatus.Overdue:
        # Overdue tasks are always urgent with higher estimated time
        return Taskpriority.Urgent, base_time + 2
    elif status == Taskstatus.In_progress:
        # In-progress tasks have slightly reduced priority and time
        return Taskpriority(base_priority.value - 1 if base_priority.value > 1 else 1), max(base_time - 1, 1)
    elif status == Taskstatus.Finished:
        # Completed tasks have no priority or time
        return Taskpriority.Low, 0

    # Default for Not Started tasks
    return base_priority, base_time



class Task:
    def __init__(self, title, deadline, category, priority, status, estimated_time):
        self.title = title
        self.deadline = deadline
        self.category = self.validate_enum(category, Taskcategory)
        self.priority = self.validate_enum(priority, Taskpriority)
        self.status = self.validate_enum(status, Taskstatus)
        self.estimated_time = estimated_time  # in hours
        self.created_at = datetime.now()

    def validate_enum(self, value, enum_class):
        if isinstance(value, enum_class):
            return value
        raise ValueError(f"{value} is not a valid {enum_class._name_}")

    def calculate_weighted_priority(self):
        return (
            self.category.weight() * 0.4
            + self.status.weight() * 0.4
            + self.priority.weight() * 0.2
        )

    def __lt__(self, other):
        return self.calculate_weighted_priority() > other.calculate_weighted_priority()

    def __str__(self):
        return (f"Task: {self.title}, Category: {self.category.name}, "
                f"Priority: {self.priority.name}, Status: {self.status.name}, "
                f"Weighted Priority: {self.calculate_weighted_priority():.2f}")


class work_session:
    def __init__(self, duration, task_id):
        self.duration = duration #Minutes
        self.task_id = task_id
        self.start_time = None
        self.end_time = None
        self.completed = False

    def start(self):
        self.start_time = datetime.now()

    def end(self):
        self.end_time = datetime.now()
        self.completed = True
        return (self.end_time - self.start_time)/ timedelta(minutes=1)


class DistractionBlocker:
    def __init__(self, duration: int, task: Task):
        # Initialize the distraction blocker with the task and duration. Duration time: in minutes
        self.duration = duration  # Duration in minutes
        self.task = task
        self.is_active = False
        self.timer = None

    def start_work_session(self):
        # Starts the focus session by enabling distraction-blocking mode.
        if self.is_active:
            print("A work session is already active!")
            return

        print(f"\nStarting work session for: {self.task.title}")
        print(f"Distraction-blocking mode activated for {self.duration} minutes.")
        self.is_active = True
        # initialize and start timer:
        self.timer = Timer(self.duration * 60, self.end_focus_session)
        self.timer.start()

    def end_focus_session(self):
        # Ends the focus session and disables distraction-blocking mode.
        if not self.is_active: # changed from self.is_active == False
          print(f"Focus session for {self.task.title} has ended.")
          print("Distraction-blocking mode deactivated. You can now check notifications.")
        self.is_active = False # This line ensures is_active is set to False after session ends.

    def pause_focus_session(self):
        """Pauses the focus session by stopping the timer."""

        if not self.is_active:
            print("No active focus session to pause.")
            return

        print(f"Pausing focus session for {self.task.title}.")
        # Check if the timer is running before attempting to cancel:
        if self.timer is not None:
            self.timer.cancel()
        self.is_active = False

    def resume_focus_session(self):
        """Resumes the focus session."""
        if self.is_active:
            print("Focus session is already active.")
            return

        print(f"Resuming focus session for {self.task.title}.")
        self.start_work_session() #changed from self.start_focus_session()


class StudentSchedule:
    def __init__(self):
        self.tasks = []
        self.urgent_tasks = []  # Priority queue for urgent tasks
        self.completed_tasks = []
        self.work_sessions = []
        self.task_categories = defaultdict(list)

    def task_addition(self, task) -> None:
        #We are adding a new task with priority and its category
        self.tasks.append(task)
        self.task_categories[task.category].append(task)

        # We are adding the urgent task to the urgent queue"
        # Corrected line: Accessing URGENT as a member of Taskpriority enum
        if (task.deadline - datetime.now() == timedelta(days=2) or task.priority == Taskpriority.Urgent):
           heapq.heappush(self.urgent_tasks, task)

    def get_urgent_tasks(self, limit) -> List[Task]:
       # Get most urgent tasks using a heap for an efficient Time management and complexity

       urgent = []  # Initialize an empty list to store the most urgent tasks.
       task_heap = self.urgent_tasks.copy()  # Create a copy of the original heap to avoid modifying it.
       for _ in range(min(limit, len(task_heap))):
        if task_heap:
          urgent.append(heapq.heappop(task_heap))  # Remove the smallest (most urgent) task from the heap and append it to the 'urgent' list.
       return urgent


    def search_tasks(self, query: str, category: str = None) -> List[Task]:
        # Searches tasks by title with an optional category filter using a greedy approach.
        matches = []
        task_list = self.tasks if category is None else self.task_categories.get(category, [])

        # Greedy method: iterate and collect matching tasks
        for task in task_list:
            if query.lower() in task.title.lower():
                matches.append(task)

        return sorted(matches, key=lambda t: (t.deadline, t.priority))

    def complete_task(self, task_title: str) -> bool:
        # Marks a task as completed by removing it from active lists and heaps.
        for task in self.tasks:
            if task.title == task_title:
                self.tasks.remove(task)
                # Change self.urgent_heap to self.urgent_tasks
                if task in self.urgent_tasks:
                    self.urgent_tasks.remove(task)
                    # Use heapq.heapify if urgent_tasks was intended as a heap
                    # heapq.heapify(self.urgent_tasks)
                self.task_categories[task.category].remove(task)
                return True
        return False

    def suggest_next_task(self) -> Optional[Task]:
        # Suggest the next task to work on using a custom scoring algorithm

        def calculate_task_score(task: Task) -> float:
            # Use TaskStatus instead of status
            if task.status != Taskstatus.Not_started:
              return -1  # Exclude tasks that aren't "Not_started"

            time_until_deadline = (task.deadline - datetime.now()).total_seconds() / 3600  # in hours
            if time_until_deadline <= 0:
              return float('inf')  # Highest priority for overdue tasks

            # Score based on priority, deadline, and estimated time
            priority_weight = {Taskpriority.Low: 1, Taskpriority.Medium: 2, Taskpriority.High: 3, Taskpriority.Urgent: 4}

            score = (priority_weight[task.priority] * 100 +  # Weight priority heavily
                    (1 / time_until_deadline) * 50 +       # Penalize for proximity to deadline
                    task.estimated_time * 0.5)            # Factor in estimated effort
            return score


        incomplete_tasks = [task for task in self.tasks if task.status == Taskstatus.Not_started]
        if not incomplete_tasks:
            return None

        # Sort tasks by score and return the highest score
        return max(incomplete_tasks, key=calculate_task_score)
    # ... (rest of the class code remains the same)

def main():
    # Initialize the scheduler
    scheduler = StudentSchedule()

def main():
    scheduler = StudentSchedule()

    print("Welcome to PrioritizeMe!")

    while True:
        # Menu for user options
        print("\nMenu:")
        print("1. Add a task")
        print("2. View all tasks")
        print("3. Suggest next task to work on")
        print("4. Start a work session")
        print("5. Exit")

        choice = input("Enter your choice (1-5): ").strip()

        if choice == '1':
            # Add a new task
            task_name = input("\nEnter the task name: ").strip()
            due_date_input = input("Enter the due date (YYYY-MM-DD): ").strip()
            if not due_date_input:
                input("Due date cannot be empty.")
                continue
            category_input = input("Enter the task category (Homework, Project, Exam, Extracurricular): ").strip().capitalize()
            if category_input not in ["Homework", "Project", "Exam", "Extracurricular"]:
                input("Invalid category. Please choose from Homework, Project, Exam, or Extracurricular.")
                continue

            print("\nChoose the task status: 1 = Not Started;  2 = In Progress; 3 = Completed; 4 = Overdue ")
            status_choice = input("Enter the status number (1-4): ").strip()
            if status_choice not in ["1", "2", "3", "4"]:
                input("Invalid status choice. Please enter a number between 1 and 4.")
                continue

            try:
                due_date = datetime.strptime(due_date_input, "%Y-%m-%d")
                category = Taskcategory[category_input]
                status = {
                    "1": Taskstatus.Not_started,
                    "2": Taskstatus.In_progress,
                    "3": Taskstatus.Finished,
                    "4": Taskstatus.Overdue,
                }[status_choice]

            except ValueError:
                print("Invalid date format. Please use YYYY-MM-DD.")
                continue


            days_until_deadline = (due_date - datetime.now()).days
            priority, estimated_time = determine_priority_and_estimated_time(category, days_until_deadline, status)

            new_task = Task(
                title=task_name,
                deadline=due_date,
                category=category,
                priority=priority,
                status=status,
                estimated_time=estimated_time
            )
            scheduler.task_addition(new_task)
            print(f"Task '{task_name}' added with priority '{priority.name}', status '{status.name}', and estimated time {estimated_time} hours.")

        elif choice == '2':
            # View all tasks
            print("\nAll Scheduled Tasks:")
            for task in scheduler.tasks:
                print(f"  {task}")

        elif choice == '3':
            # Suggest next task
            print("\nSuggested Task to Work On:")
            suggested_task = scheduler.suggest_next_task()
            if suggested_task:
                print(f"  {suggested_task}")
            else:
                print("Suggestion not available since there is only 1 task to work on")

        elif choice == '4':
            # Start work session
            task_title = input("\nEnter the task title to start work on: ").strip()
            task = None
            for t in scheduler.tasks:
                if t.title == task_title:
                    task = t
                    break

            if task:
                # Initialize and start the distraction blocker
                duration = int(input("Enter the duration for the work session (in minutes): "))
                blocker = DistractionBlocker(duration=duration, task=task)
                blocker.start_work_session()
            else:
                print(f"Task '{task_title}' not found.")

        elif choice == '5':
            # Exit the program
            print("Exiting PrioritizeMe")
            break

        else:
            print("Invalid choice. Please select an option between 1 and 5.")

if __name__ == "__main__":
    main()

